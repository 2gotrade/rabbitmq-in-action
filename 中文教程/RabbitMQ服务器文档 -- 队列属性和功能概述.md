# 队列属性和功能概述

## 介绍

由于消息系统中的许多功能与队列相关，因此这并不是一个非常详细的指南，而是仅仅对RabbitMQ中的队列概述。

本指南主要介绍AMQP 0-9-1上下文中的队列，但其中大部分内容适用于其他支持的协议。

一些协议（例如STOMP和MQTT）是基于主题的思想。对于他们来说，队列是一个实现细节。

## 名称

为了应用程序可以引用队列，它们应该具有名称。

应用程序可以选择队列名称或要求代理为其生成名称。队列名称最多可以是255个字节的UTF-8字符。

名称以“amq”开头的队列被保留供broker内部使用。如果您尝试声明具有违反此规则的名称的队列将导致具有回复代码403（ACCESS_REFUSED）的通道级异常。

## 服务器命名的队列

在AMQP 0-9-1中，broker可以代表应用程序生成唯一的队列名称。如果要使用此功能，请传递一个空字符串作为队列名称参数：通过使用期望队列名称的空字符串，可以通过同一通道中的后续方法获得相同的生成名称。这是因为通道会记住最后一个服务器生成的队列名称。

**属性**

队列具有定义其行为方式的属性。有一组强制属性和可选的属性映射：

1. Name - 名称
2. Durable - 持久化（队列将在broker重新启动后可以被恢复）
3. Exclusive - 排它性（仅可以被一个连接使用，当该连接关闭时，队列将被删除）
4. Auto-delete - 自动删除（队列至少有一个消费者，在最后一个消费者取消订阅时将被删除）
5. Arguments - 参数（可选;供插件和特定broker的功能使用，如消息TTL，队列长度限制等）

## 声明与属性等价

在使用队列之前，必须声明它。声明一个队列时,如果它不存在它将被创建。如果队列已经存在且其属性与声明中的相同，则声明将不起作用。当现有的队列属性与声明中的队列属性不同时，会引发一个包含代码406（PRECONDITION_FAILED）的通道级异常。

## 可选参数

在AMQP 0-9-1协议的字段名称中，可选队列参数也称为“x参数”，它是一种映射（字典），可以在客户端声明队列时提供该参数。它们被插件和broker特定的功能所使用：

- 消息和队列TTL（Message and queue TTL）
- 队列长度限制（Queue length limit）
- 镜像设置（Mirroring settings）
- 最大优先次数（Max number of priorities）
- 消费者优先（Consumer priorities）

可选参数可以通过两种方式提供：

1. 使用策略的队列组（推荐）
2. 当队列由客户端声明时，在每个队列的基础上设置

前一种选择更灵活，不侵入，不需要应用程序修改和重新部署。因此，强烈建议大多数用户使用。

可选参数由客户提供不同的方式从客户端库的客户端库，但通常是持久化（durabl）、自动删除（auto_delete）和其他一些参数的函数（方法）是在声明队列时提供的。

## 消息排序

RabbitMQ中的队列是消息的有序集合。消息以FIFO的方式排队并排队（消耗），尽管优先级队列，分片队列和其他功能可能会影响到这一点。

## 持久化

持久化的队列会持久存储到磁盘，从而可以在broker重新启动后可以被恢复。不持久化的队列称为临时队列。并非所有情况和用例都要求队列持久化的。

队列的持久化不会使路由到该队列的消息持久化。如果broker被停掉然后被备份，持久化队列将在broker启动期间被重新声明，但只有消息排序的消息将被恢复。

## 临时队列

有些工作负载队列应该是短暂的。虽然客户端可以在断开连接之前删除声明的队列，但这并不是很方便。最重要的是，客户端连接可能会失败，可能会留下未使用的资源（队列）。

实现自动删除队列有三种方法：

1. Exclusive queues - 排他队列
2. TTL - 过期时间
3. Auto-delete queues - 自动删除队列
（例如，使用了在其最后一个消费者取消了自动删除队列将被删除basic.cancel在AMQP 0-9-1）或消失（封闭的通道或连接，或与服务器失去TCP连接）。

如果一个队列从来没有任何消费者，例如，当所有消费都使用basic.get方法（“pull”API）时，它不会被自动删除。对于这种情况，请使用独占队列或队列TTL。

## 排他队列

排他队列只能通过其声明连接使用（消耗，清除，删除等）。如果尝试使用来自不同连接的排他队列将导致信道级异常  RESOURCE_LOCKED与错误消息: 不能获得对锁定队列的独占访问。

当连接正常关闭或异常关闭（例如由于底层TCP连接丢失）时，排他队列将被删除。因此，它们仅适用于客户端特定的瞬态。

通常使用服务器命名的排他队列

## 镜像和分布式队列

队列可以跨群集节点进行复制，并联合到松散耦合的节点或群集中。请注意，镜像和联合是正交特征，不应被视为直接替代方案。

## 生存时间和长度限制

队列的长度是有限制的。队列和消息都可以有TTL。

这两个功能都可以用于数据到期，也是限制队列最多可以使用多少资源（RAM，磁盘空间）的方法，例如，当消费者脱机或其吞吐量落后于发布者时被使用。

## 内存和持久存储

队列将消息保留在RAM和（或）磁盘上。在某些协议（例如AMQP 0-9-1）中，这部分由客户端部分控制。在AMQP 0-9-1中，这是通过消息属性（delivery_mode或在某些客户端中持久化）完成的。

在RabbitMQ中应该保持短暂的尽可能多的信息在内存中。但是，当发现自己的队列处于内存压力下时，队列仍然需要将消息发送到磁盘的。

路由到持久队列的持久消息将分批存储，或者在一定时间（秒）内传送。

无论其持久性属性如何，懒惰队列将消息输出到磁盘更为积极。

有关详细信息，请参阅内存使用，警报， 内存警报， 可用磁盘空间警报， 生产清单和消息存储配置指南。

## 优先级

队列可以有0个或更多的优先级。此功能是可选的：只有通过可选参数（见上文）配置的最大优先级数的队列将执行优先级排序。

发布者使用消息属性中的优先级字段指定消息优先级。

如果需要优先级队列，我们​​建议使用1到10之间。目前使用更多的优先级将消耗更多的资源（Erlang进程）。

## CPU利用率和并发性考虑

目前，单个队列（主机或镜像）仅限于其热代码路径上的单个CPU内核。因此，此设计假设大多数系统在实践中使用多个队列。单个队列通常被认为是反模式（而不仅仅是为了资源利用的原因）。

如果希望对消息顺序排序（更好的CPU核心利用率）进行交换，那么rabbitmq-sharding会 为客户端提供透明的方式。

## 指标和监测

RabbitMQ可以收集有关队列的多个指标。大多数都可以通过RabbitMQ HTTP API和管理UI来实现，该UI是专为监控而设计的。这包括队列长度，进出率，消费者数量，各种状态下的消息数量（例如，准备交付或未确认的消息），RAM中的消息数量与磁盘上的消息等等。

rabbitmqctl可以列出队列和一些基本度量。

可以使用管理UI中的rabbitmq-top插件和单个队列页面访问诸如VM调度程序使用情况，队列（Erlang）进程GC活动，队列进程使用的RAM数量，队列进程邮箱长度等运行时指标。

## 消费者和确认机制

消息可以通过注册消费者（订阅）来消费，这意味着RabbitMQ会将消息推送到客户端，或者单独获取用于支持此功能的协议（例如，basic.get AMQP 0-9-1方法），与HTTP GET类似。

交付消息可以在消息发送到连接套接字后立即被消费者明确或自动确认。

自动确认模式通常将提供更高的吞吐率并且使用较少的网络带宽。然而，它提供了最少的保障，当涉及到失败。根据经验，首先考虑使用手动确认模式。

## 预取和消费过载

自动确认模式也会导致消费过载，因为消费者不能尽快处理消息。这可能导致消费者进程的内存使用或操作系统交换的持久增长。

手动确认模式提供了一种设置未完成（未确认）传送数量限制的方法：信道QoS（预取）。

使用更高（数千或更多）预取级别的消费者可能会遇到与使用自动确认的消费者相同的过载问题。

大量未确认的消息将导致broker更高的内存使用量。

## 消息状态

入队消息可以是两种状态之一：
1. 准备交付
2. 由消费者尚未确认的交付

消息按状态细分可以在管理界面中找到。

## 确定队列长度

可以通过多种方式确定队列长度：

1. 使用AMQP 0-9-1，使用queue.declare方法响应（queue.declare-ok）上的属性。字段名称为message_count。访问方式从客户端库到客户端库不同。
2. 使用RabbitMQ HTTP API。
3. 使用rabbitmqctl  list_queues命令。
4. 队列长度定义为准备传送的消息数。
