# 消费者优先事项

消费者优先级允许您确保高优先级消费者在活动时接收消息，只有当高优先级消费者消息阻塞时，消息才会转到较低优先级的消费者。

通常，连接到队列的活动消费者以循环方式从其接收消息。当使用消费者优先级时，如果存在具有相同高优先级的多个活动消费者，消息将轮询。

## 活跃消费者的定义

上述将消费者分为了活跃的和阻塞的。任何时候任意给定的消费者肯定是其中的一种。活跃的消费者是可以接收消息而不需要等待的消费者。消费者如果无法接收到消息被阻塞， 因为它的信道在发出basic.qos之后已达到最大数量的未确认消息 ，或者仅仅是因为网络拥塞。

因此，对于每个队列，一个以下三件事中必须至少有是真的：

- 没有活跃的消费者
- 队列是空的
- 队列忙于向消费者传递消息

请注意，消费者每秒可以在多次活跃和阻塞之间切换。因此，我们不暴露消费者是否激活，或者通过管理插件或阻止  rabbitmqctl。

当使用消费者优先级时，您可以期望最高优先级的消费者接收所有消息，直到其被阻止为止，此时低优先级消费者将开始接收某些消息。了解RabbitMQ仍然会优先处理邮件，这一点非常重要 - 如果有低优先级的消费者准备就绪，则不要等待高优先级的阻止消费者解除阻塞。

## 使用消费者优先

在basic.consume方法设置参数x-priority为一个整数。不指定值的消费者具有优先级0。较大的数字表示更高的优先级，可以使用正负数字。

例如（在Java中）：

	Channel channel = ...;
	Consumer consumer = ...;
	Map<String, Object> args = new HashMap<String, Object>();
	args.put("x-priority", 10);
	channel.basicConsume("my-queue", false, args, consumer);

这创建了一个优先级为10的新消费者。

