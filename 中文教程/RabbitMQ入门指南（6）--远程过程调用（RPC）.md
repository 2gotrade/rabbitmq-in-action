# RabbitMQ入门指南（6）--远程过程调用

**声明**：本文都是参考RabbitMQ的官方指南翻译过来的，由于本人水平有限难免有翻译不当的地方，敬请谅解。

> **前提条件**

> 本教程假定RabbitMQ 已在标准端口（5672）上的localhost上安装并运行。如果使用不同的主机，端口或凭据，连接设置将需要调整。 

*摘要: 实现远程调用*

## 远程过程调用-RPC（使用Java客户端）

在第二个教程中，我们学习了如何使用工作队列将耗时的任务分配到多个工作者中。

但是如果我们需要在远程计算机上的函数运行功能并等待结果怎么办？那么这就是另外一种模式了，此模式通常称为远程过程调用或RPC。

在本教程中，我们将使用RabbitMQ构建一个RPC系统：一个客户端和一个可扩展的RPC服务器。由于我们没有任何值得分散的耗时任务，我们将会创建一个虚拟的RPC服务，用来返回Fibonacci(斐波纳契数列)。

## 用户接口

为了说明如何使用RPC服务，我们将创建一个简单的客户端类。它将暴露一个名为call的方法，该方法 发送RPC请求，并在响应回复之前都会一直阻塞：

	FibonacciRpcClient fibonacciRpc = new FibonacciRpcClient();
	String result = fibonacciRpc.call("4");
	System.out.println( "fib(4) is " + result);

> **关于RPC**

> 虽然RPC是一个很常见的计算模式，但是它依旧常常受批判的。当程序员不知道函数调用是本地函数还是缓慢的RPC时，会出现问题。这样的混乱导致了一个不可预知的系统，并增加了调试的不必要的复杂性。而不是简化软件，滥用RPC可能导致不可维护的意大利面条代码（译者注：原文是spaghetti code可能形容代码很长很乱）。

> 铭记这一点，请考虑以下建议：

> 确保显而易见哪个函数调用是本地的，哪个是远程调用的。

> 给您的系统加上文档，让组件之间的依赖项清晰可见的。

> 处理错误情况。当RPC服务器长时间停机时，客户端应该如何反应？

> 于RPC的所有疑问消除，在你可以的情况下，你应该使用一个异步的管道，代替RPC中阻塞，结果会异步的放入接下来的计算平台。

















