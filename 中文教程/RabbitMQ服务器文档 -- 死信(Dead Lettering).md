# 死信交换

来自队列的消息可以是“dead-ttered”; 也就是说，当发生以下任何事件时，会再次发布到另一个交换机：

1. 消息被拒绝（basic.reject或  basic.nack）与requeue = false，
2. 消息的TTL过期
3. 超出队列长度限制。

死信交换（DLX）是正常的交换。它们可以是任何正常的类型，并且照常被声明。

对于任何给定的队列，DLX可以由使用队列参数的客户端定义，或者使用策略在服务器中定义。在策略和参数都指定DLX的情况下，参数中指定的参数会覆盖策略中指定的参数。

## 使用参数进行配置

要设置队列中的死信交换，请将x-dead-letter-exchange参数设置为交换机的名称：

	channel.exchangeDeclare("some.exchange.name", "direct");
	
	Map<String, Object> args = new HashMap<String, Object>();
	args.put("x-dead-letter-exchange", "some.exchange.name");
	channel.queueDeclare("myqueue", false, false, false, args);

上面的代码声明一个名为some.exchange.name的新交换机 ，并将此新交换机设置为新创建的队列的死信交换。请注意，当队列被声明时，不需要声明交换，但应声明消息存活的时间; 如果丢失，则该消息将被静默地删除。

您还可以指定一个路由关键字，以便死信消息使用。如果未设置，则将使用消息自己的路由关键字

	args.put("x-dead-letter-routing-key", "some-routing-key");

当指定了死信交换时，除了声明队列上的常规配置权限外，用户需要对该队列具有读取权限，并对死信交换写入权限。队列声明时验证权限。

## 使用策略配置

要使用策略指定DLX，请将密钥“dead-letter-exchange”添加到策略定义中。例如：

**rabbitmqctl**
	
	rabbitmqctl set_policy DLX ".*" '{"dead-letter-exchange":"my-dlx"}' --apply-to queues

**rabbitmqctl (Windows)**
	
	rabbitmqctl set_policy DLX ".*" "{""dead-letter-exchange"":""my-dlx""}" --apply-to queues

这将DLX“my-dlx”应用于所有队列。

类似地，可以通过向策略添加密钥“dead-letter-routing-key”来指定显式路由密钥。

还可以使用管理插件定义策略，有关详细信息，请参阅[策略文档](http://www.rabbitmq.com/parameters.html#policies)。

## 路由死亡消息

已经放弃的消息将路由到他们的死信交换：

为它们所在的队列指定了路由关键字; 

如果没有设定，与它们最初发布的路由密钥相同。

例如，如果您将消息发布到具有路由关键字foo的交换机，并且该消息已经被删除，则它将被发布到与路由关键字foo的死信交换。如果消息原始登陆的队列已经被  x-dead-letter-routing-key设置为  bar，那么该消息将被发布到与路由关键字bar的死信交换 。

请注意，如果没有为队列设置特定的路由关键字，那么其上的消息将以所有原始路由关键字的形式被删除。这包括由CC和BCC标头添加的路由关键字（有关这两个标头的详细信息，请参阅发送方选择的分发）。

消失的消息通过发布者内部确认机制将被重新发布，所以消息最终登陆的“死信队列”（DLX路由目标）必须在将消息从原始队列中删除之前确认。换句话说，“发布”（消息过期的）队列将不会在死信队列确认接收消息之前删除消息（有关所作保证的详细信息，请参阅 确认）。请注意，在未完全关闭broker的情况下，相同的消息可能会在原始队列和死信目标队列上重复。

这样可能形成一个消息死信的循环。例如，当队列将消息传递到默认交换而不指定死信路由关键字时，就可能会发生这种情况。如果在整个周期内没有拒绝，这样的周期中的消息（即到达同一个队列的消息是两次）将被丢弃。

## 死信消息

修改死信消息的标题时：

1. 交换名称被替换为最新的死信交换的名称，
2. 路由关键字可以被替换为执行死信的队列中指定的，
3. 如果发生上述情况，CC标题也将被删除，BCC头将按照被移除 发件人选择的分发。

死信消息将添加一个名为x-death的数组到每个死信消息的标题中。该数组包含每个死信事件的条目，由一对{queue，reason}标识。每个这样的条目是由几个字段组成的表：

1. queue 队列 - 消息在死亡之前所在的队列的名称，
2. reason 原因 - 见下文，
3. time 时间 - 消息死亡的日期和时间字母为64位AMQP格式时间戳，
4. exchange 交换 - 信息发布的交换（请注意，如果邮件多次被填写，这将是一封死信交换），
5. routing-keys 路由关键字 - 发布消息的路由关键字（包括CC关键字，但不包括  BCC）
6. count 计数 - 这个消息在这个队列中死了多少次，
7. original-expiration 原始到期（如果消息由于每个消息TTL而死亡） - 消息的原始到期属性。该到期属性从死刻字的消息，以防止它在它被路由到任何队列再次到期删除。

新的条目预先放在x-death 阵列的开头。如果x-death已经包含一个具有相同队列和死字的原因的条目，则其计数字段将被递增，并将其移动到数组的开头。

原因（reason）是描述为什么消息是死的，是下面的一个名字：

1. rejected（被拒绝） - 消息被requeue = false拒绝，
2. expired（过期） - 消息的TTL过期; 要么
3. maxlen - 超出允许的最大队列长度。

请注意，该数组是最新排序的，因此最近的死字将被记录在第一个条目中。
